세팅 하는 방법 

C 과목은 메모장 코딩

메모장 코딩을 하는 이유
C를 실무에서 사용할 경우 IDE를 못 쓰는 환경이 많아서 메모장으로 코딩함
디버깅도 직접하기 때문에 실력 향상 가능성

비주얼 스튜디오 컴파일러는 C 표준을 지키지 않는 경우 있음
우리는 clang 컴파일러를 사용

===================================================================

https://releases.llvm.org/download.html
Clang 8.0.1 목록으로 들어가서
Windows (32 or 64 bit).sig 파일 다운로드 후 실행.

Add LLVM to the system PATH for all users (환경 변수 설정) 선택 및 다음 진행
설치가 완료되면, CMD를 켜서 clang --version 명령어를 입력해볼 때
버전 결과가 출력되야 함(환경 변수 설정이 안 되면 안 뜸)

===================================================================

C:\Users\user> clang --version
clang version 8.0.1 (tags/RELEASE_801/final)
Target: x86_64-pc-windows-msvc
Thread model: posix
InstalledDir: C:\Program Files\LLVM\bin

이렇게 뜨는게 정상으로 잘 깔린 것
========================================================= 

.c 확장자의 파일을 생성하여 다음 코드 작성 후 저장.

#include <stdio.h>
int main(void)
{
    printf("Hello World!\n");
    return 0;
} /* 이 아래줄까지 파일의 끝임. 한 줄은 항상 비워둘 것 */

===========================

빌드 명령어 작성 : clang -std=c버전 -W -Wall -pedantic-errors 컴파일할파일이름.c -o 실행파일이름.exe
명령어를 입력하면 실행 파일이 제대로 생성되는지 확인. 
코드에 이상이 있을 경우, 컴파일 에러도 출력되는지 확인.

===========================

안할경우 엔드라인은 빈 줄이여야 한다고 오류가 뜸

C:\C> clang -std=c89 -W -Wall -pedantic-errors Test.c -o Test.exe
Test.c:7:2: error: no newline at end of file [-Werror,-Wnewline-eof]
}
 ^
1 error generated.

잘 실행 될때

C:\C> clang -std=c89 -W -Wall -pedantic-errors Test.c -o Test.exe

C:\C>Test.exe // 확장자를 넣어도 됨
Hello World!

C:\C>Test
Hello World!


=====================================

빌드 명령어 설명

-W -Wall -pedantic-errors

컴파일러가 최대한 c 표준에 맞도록 깐깐하게 검사하겠다는 뜻
조금이라도 어긋나면 에러를 나게 하겠다.

두개의 파일을 빌드하고 싶을때 파일명 적는 곳에 2개의 파일 이름을 적으면 됨
*.c로 입력하면 확장자가 c인 모든 파일을 포함

*.* 경로에 있는 모든 파일들을 선택

-o 
생성할 실행 파일의 이름을 직접 설정할 수 있게 해주는 명령어

==========================================

c와 c++은 언매니지드 언어 개발자가 직접 메모리를 관리해야 하는 언어
매니지드는 반대로 직접 관리해주지 않아도 됨

언매니지드 언어를 알면 매니지드 언어를 사용할 때 좀 더 효율적인 코드를 짤 수 있음

성능이 필요한 분야에서는 언매니지드 언어가 우위

c와 c++로 만든 것
운영체제, 언리얼 엔진, 유니티, 포토샵

언매니지드 언어를 공부하기 때문에 메모리를 중점으로 공부
c언어가 언매니지드 언어를 공부하기 좋음

임베디드(의료,음향,반도체 등등) 업계에서 많이 사용
AI 사용할때도 c나 c++을 사용

언매니지드 언어를 이해하면 cpu 동작이나 메모리 구조 등등을 알 수 있음
컴퓨터가 어떻게 이해하는지도 알 수 있어서 효율적인 코드 작성 가능성
하드웨어에 가까운 언어 

c와 c++은 메모리 조작 가능(포인터)
해킹, 매니지드 언어에선 불가능한 최적화가 가능

가비지 컬렉터보다 효율적인 코드 작성 가능
매니지드 언어는 메모리 조작을 못하게 함
반대로 말하면 메모리 조작을 잘 못하는 개발자를 위해서 좋음
언매니지드 언어는 개발자가 메모리를 이해못하면 성능이 더 않좋아짐

-> 세팅, c언어를 배워야 하는 이유


========================================

문법 표준이 생긴 이유
같은 코드라도 컴파일러에 따라 다른 기계어로 변환될 수 있기 때문

표준이 없던 시절

컴파일러가 달라서 A에선 잘 동작되는 코드가 B에선 동작이 안됨


C 표준을 크게 3개로 분리하면 (c뒤에 붙은 숫자는 표준이 나온 연도)
하지만 대부분 c89를 기반하고 그것을 개선한 것임

1989 c89 표준
c90표준이랑 거의 똑같음

c99표준 

c11 이후 표준 모던 c라고 불림

c89 표준은 
한줄 주석이 안됨 //가 없음
/* */ 이거밖에 없음

========================================================

c언어는 절차지향만 되고 c#은 절차지향 개체지향 둘 다 가능함

애초에 개체지향이라는 패러다임이 나오기 전에 개발된 언어
예외가 없음 
예외는 프로그램이 안정적으로 돌아가게 하는 것이 아님
프로그래머가 알아보기 쉽게 해둔 것

c언어가 절차지향밖에 안되는 이유
컴퓨터가 절차지향식이라서 하드웨어랑 비슷하게 돌아가기 때문에 빠르기 때문

사람은 데이터를 하나로 묶고 싶어하기 때문에
개체지향은 사람에 생각에 맞춰서 나온 패러다임임
사람마다 주관성이 달라서 같은 것을 배우더라도 다르게 이해함
사람마다 코드가 다름 
그래서 개체지향은 주관적임

절차지향은 기계에 최적화된 코드를 짜야하기 때문에 다 비슷함

=======================================

모든 함수는 전역 함수는

변수는 지역과 전역밖에 없음

c언어는 .c 파일과 .h 파일로 나뉨
왜 두개인가

c언어가 나올 시기는 기기 성능이 좋지 않기 때문에 
2개로 나눠서 하는게 더 좋았음

한 종류로 만드는데 언어나 툴이 딸림

요즘에는 다 해줌

include 뒤에 있는 파일을 포함시키겠다는 뜻
stdio.h 안에 있는 변수나 함수를 사용할 수 있음

c c++에서는 텍스트를 복붙해서 가져옴

c#의 using은 이것을 개선해서 복붙해서 가져오진 않지만
추가적인 작업을 해서 느림

헤더파일은 무엇인가~~

불러들여 와서 사용할 변수나 함수가 있는 파일
헤더파일은 c 파일에 사용할 변수랑 함수 선언용 파일이고
c 파일은 선언된 함수를 정의하고 사용할 파일

헤더파일 이름이 기억하기 힘들어서 복습잘하는 게 좋음

이름이 헤더파일인 이유

위쪽이라는 뜻인데 
헤더파일이 변수랑 함수가 선언된 파일인데 선언이 먼저오고
정의가 오거나 사용코드가 오는데
선언 코드는 항상 위쪽에 있기 때문에 헤더파일이다.

C#은 함수의 정의 순서를 신경쓰지 않는데
c는 정의 순서를 엄밀히 따지기 때문에 순서가 중요함
나중에 배움(빌드 과정)

아직 컴파일러가 못 읽은 코드는 사용할 수 없다.

C#은 함수를 선언하는 부분이 없음

abstract 함수는 개체지향 코드이기 때문에 다름
동적 바인딩(다형성,오버라이딩), 정적 바인딩(그런거 없음)

====================================
왜 파일이 두 종류여야 하는가는 빌드 과정 공부할 때 다시 배움
다른 파일에 선언된 변수와 함수를 가져다 쓰기 위해서 헤더파일이 존재함

c 파일을 include 하는 경우도 있음
빌드 속도를 빠르게 하기 위한 상황

c++ 유니티 빌드 키워드로 검색

<> 가 무슨 의미인가 
"" 도 있음

<>는 c 표준 라이브러리에 있는 헤더파일을 가져오겠다는 의미
입출력 기능, 수학 기능 등등 

표준 라이브러리 파일은 일반적으로 
C:\Program Files (x86)\Windows Kits\10\Include버전\ucrt
폴더에 담겨있음.

일단 표준 라이브러리에 있는지 확인 없다면
내 프로젝트 경로(워킹 디렉토리)에서도 찾음

베스트 프랙티스

표준 라이브러리는 <>
내가 만든 건 ""

================================== main 함수의 의미

엔트리 포인트라고도 함

프로그램을 실행하는 프로그램이 있음
그때 프로그램이 정상적으로 끝났는지 알기 위해 int 반환을 사용

배치파일 에러레벨 검색

================================ printf 의미

print format 

서식 문자가 있음 
printf뒤에 들어가는 매개변수들

대표적인 서식 문자 종류 : 
%s : 문자열로 서식 문자열에 표현
%c : 문자로 서식 문자열에 표현
%d : 정수로 서식 문자열에 표현
%f : 실수로 서식 문자열에 표현
%u : unsigned

예시 :
/* 안녕 학생! 좋은 하루 */
printf("안녕 %s! 좋은 하루", "학생");

/* 1 + 2 = 0.000000  정수형을 실수로 표현하려 했기 때문 */
printf("%s + %c = %f\n", "1", '2', 3); 

/* 65  65인 이유가 궁금하면, 아스키 코드를 검색해볼 것) */
printf("%d", 'A'); /* 문자 A를 정수형으로 바꾼 뒤 출력하는 코드 */

모든 문자는 숫자랑 대응이 됨
그게 아스키코드

================================================================ 변수 선언

지역변수의 경우
변수 선언이 되는 위치는 블럭이 시작되는 부분에 적는게 좋음

아래와 같은 코드 작성 불가능

int num = 3;
printf("%d", num);
int num2 = num + 3; /* 컴파일 에러 */

즉 위에서 변수 선언해두고 아래에서 대입해야 함..
int num = 3;
int num2;

printf("%d", num);
num2 = num + 3;

c89에서는 이렇게 해야함

C:\C> clang -std=c89 -W -Wall -pedantic-errors Test.c -o Test.exe
Test.c:7:9: error: ISO C90 forbids mixing declarations and code [-Werror,-Wdeclaration-after-statement]
    int num2 = num + 3;
        ^

c99이전까지는 안됨
이렇게 뜸

이를 해결하기 위해 블럭을 중간에 추가하면 중간 선언도 가능하지만
여전히 들여쓰기로 인한 가독성은 좋지 않음.
int num = 3;
printf("%d", num);

{ /* 블럭이 새로 시작되므로 선언 가능. 하지만 블럭이 끝나면 다시 못 씀 /
    int num2 = num + 3;
}

printf("%d", num2); / 컴파일 에러 */

========

C:\C> clang -std=c89 -W -Wall -pedantic-errors Test.c -o Test.exe
Test.c:9:13: warning: unused variable 'num2' [-Wunused-variable]
        int num2 = num +3;
            ^
Test.c:12:18: error: use of undeclared identifier 'num2'; did you mean 'num'?
    printf("%d", num2);
                 ^~~~
                 num
Test.c:5:9: note: 'num' declared here
    int num = 3;
        ^
1 warning and 1 error generated.

============================== 기본 자료형

c언어는 최소 몇비트로 정해져 있음
그 시절에는 성능이 좋지 않았기 때문에

char 는 항상 1바이트
int도 4바이트 

하지만 바이트안에 들어가는 비트수는 다름

오른쪽으로 갈수록 데이터 표현 범위가 넓은 자료형
정수형 : char, short, int, long (long int 지만 생략 가능)
실수형 : float, double, long double

char는 문자 데이터 처리를 하는데 특화된 정수형
컴퓨터가 처리할 수 있는 데이터의 최소 단위 
항상 char 는 1바이트
비트는 데이터를 저장하는 최소 단위

short는 int랑 long이랑 세트

short는 int보다 연산속도보단 느리지만 메모리를 아낄 때 쓰임
표현범위가 적음

int는 cpu가 연산하는데 최적화된 자료형

long은 16비트 환경때 int보단 범위가 컸지만 요즘같은
32비트 64비트 환경에선 int랑 똑같다.

16비트 환경에서만 int보다 long이 큼

C#에 있는 long은 int보다 큼 64비트

c에서는 c99에서 long long으로 나옴

float, double, long double

float이 연산속도가 빠르지만 double보단 정밀도가 낮다.

double은 실수를 표현하는 가장 기본적인 자료형 리터럴 연산자가 붙지 않음
f같은 접미사

long double double 보다도 정밀도가 높음

실수를 쓸 때 빠른 연산속도가 필요하면 float 
정밀도는 double, long double

정밀도 
소수점을 더 많이 표현할 수 있음
변수에 담는 실수가 담으려는 실제 실수랑 관련이 없음

얼마나 같은지보다 얼마나 표현할 수 있나라고 정의하면 됨

IEEE754, 유효숫자, 정교화된 과학적 표기법 으로 검색

유효숫자를 몇자리나 많이 표현하나가 중요
포큐 수학강의에 있음

부동소수점 오차란?

변수에 실제 값이 비트에 표현되는 값과 다른 것

두가지 경우

1번째 경우
실수를 변수에 담을때 부족한 경우 데이터 손실 발생

1 % 3 같은 경우 

0.33333333... 이지만 비트는 표현을 못함

2번째 경우
실수를 2진수로 표현을 못할 때

부동소수점 연산 조심

double이라고 오류가 적어지는게 아님

float : 0.100000001490116119384765625000
double : 0.100000000000000005551115123126

for문으로 0.1을 100번 더 했을때
float : 10.100002288818359375000000000000

정확하진 못하지만 넓은 범위의 근사치를 표현할 수 있다.

부동소수점 고정소수점 차이

근사치를 표현해도 될땐 부동소수점
은행이나 금융쪽 정확한 연산이 필요할땐 고정소수점

정수자료형에서 unsigned와 signed
부호 비트를 쓸 것이냐 안 쓸것이냐에 따라 다름

unsigned char 0 ~ 255
모든 비트를 숫자를 표현하는데 씀

2진수로 8자리 표현

부호비트를 사용하지 않으면 unsigned
사용하면 signed

-128 ~ 127 // 일반적 음수에 하나 더 줌
-127 ~ 128 

컴파일러의 따라 다름

2의 보수 검색

실수는 unsigned가 없음

항상 부호 비트가 존재함
IEEE754 표기법에 따름

unsigned에 signed 값을 넣으면 언더플로우 현상 발생
최대값으로 들어감

unsigned int num = -1; /* signed 정수가 unsigned 정수로 암묵적 형변환 후 대입됨 /
printf("%u", num); / 4294967295 (언더플로우 됨) */

숫자만 넣으면 int 숫자 뒤에 u를 붙이면 unsigned int 자료형

3.f 3.0f 두가지 방식

bool

c89에 없음

c99에선 
TRUE(1) FALSE(0) 라는 define 밖에 없음
대체되는 거라고 보면 됨
여전히 없음 그냥 표준에서 만들어 준 거임

0이면 거짓
0이 아닌 값이면 참

하지만 0과 1로 표현하는것이 좋다
아니면 위의 예처럼 define을 해주는 것이 좋다.

/* 대표적인 무한루프 예 */
while (1) {
}

/* 안 좋은 예시 */
while (count) {
    printf("%d\n", count);
    --count;
}

/* 개선한 예시 */
while (1) {
    printf("%d\n", count);
    --count;

    if (count == 0) {
        break;
    }
}

enum 자료형 

c#이랑 다름

c언어는 정수형으로 취급 
상수형 변수처럼 정수로 취급

enum dir_type { LEFT, RIGHT };
enum weapon_type { SWORD, SHIELD };

enum dir_type dir = SWORD; /* enum dir_type 형인데 대입됨 /
int weapon = SHIELD; / int 형인데 대입됨 */

이게 가능한 이유 그냥 정수니까 

나중에 typedef를 배우면 편하게 쓰는 방법을 알 수 있음
enum dir_type => dir_type
변수 선언할 때 이렇게 할 수 있음

============================

베스트 프랙티스로 enum의 각 요소에는 앞에 enum타입 이름을 넣고 _로 구분하기
enum dir_type { DIR_TYPE_LEFT, DIR_TYPE_RIGHT };
enum weapon_type { WEAPON_TYPE_SWORD, WEAPON_TYPE_SHIELD };

/* 여전히 대입은 되지만 잘못 넣었음을 이전보다 쉽게 파악 가능 */
enum dir_type dir = WEAPON_TYPE_SWORD;


자료형 정리
정수형 : char, short, int, long (int)
실수형 : float, double, long double
bool 
enum

======================== 연산자

- 연산자 우선순위란

한 구문에 서로 다른 연산자가 있을 때 우선순위가 높은 연산자부터 연산을 한다.
2 + 3 * 4가 있으면 3 * 4의 연산을 먼저 하고 그 다음에 2를 더하게 됨.
즉 *가 +보다 우선순위가 높음

- 연산자 결합 법칙

한 구문에 같은 연산자가 있을 때

왼쪽부터 연산할지 오른쪽부터 연산할지

2 + 3 * 4 + 5가 있으면 3 * 4의 연산을 먼저 하고(여기까진 우선순위)
2 + 12 + 5가 되므로 2 + 12를 연산하고 14 + 5를 연산하게 됨
a = b = c가 있으면 b = c 연산을 먼저하고 a = b(c와 같은 값) 연산을 하게 됨.

- 피연산자와의 평가 순서
함수를 배우고 난 후 다시 나옴

sizeof() 연산자
메모리 용량을 알려줌 
컴파일시 결정

size_t 라는 자료형으로 대체

음수를 줄 수 없기 때문
표준 라이브러리에서 unsigned 정수를 typedef로 정의한 것

int num;
int* pnum;
scanf("%d", &num); /* num 입력 */
pnum = malloc(num);

printf("%d", sizeof(pnum)); /* 컴파일 에러 */

용량이 런타임에 결정되는 값이기 때문이다.

동적할당은 나중에 뒤에서 배움

배열 요소에 접근할 때 size_t 를 변수로 만들어 사용하기도 함

_t 로 끝나는것들은 라이브러리에서 어떤 기본 자료형들을 typedef 한 것들임

=======================================

size_t 예시

char ch;
char str[10];

size_t ch_size = sizeof(ch); /* 1u /
size_t str_size = sizeof(str); / 10u */

int arr[10];
size_t i;
for (i = 0; i < 10; ++i) {
    printf("%d ", arr[i]);
}

- 비교 연산자

== != >= <= < >

0 or 1을 반환

================================ switch case

case 뒤에 들어가는 것은 상수만 가능
ex) case 'A':

c#은 문자열도 가능 하지만 c는 안됨

c는 case에 break가 없어도 됨

=============================

fall through 베스트 프랙티스 : 필요한 경우 주석으로 명시할 것. 하지만 생각보다 쓸 일이 별로 없음

ex : 게임 패키지 아이템 구매하는 경우, 초보자 패키지 사면 강력한 검도 추가로 춤 (억지로 만든 예)
switch (buy_item_type) {
    case ITEM_TYPE_HEAVY_SHIELD:
        buy_shield(SHIELD_TYPE_HEAVY);
        break;
    case ITEM_TYPE_NOOB_PACKAGE:
        buy_package(PACKAGE_TYPE_NOOB);
        /* fall-through */
    case ITEM_TYPE_STRONG_SWORD:
        buy_sword(SWORD_TYPE_STRONG);
        break;
    default:
        assert(0);
        break;
}

=============================== 반복문

foreach 없음 부우우우우울편

for문에서 중간 선언하는 실수가 많음

/* 안됨 */
for(int i = 0; i < 10; i++){
}

/* 이렇게 선언해야 됨 */
int i;
for (i = 0; i < 10; i++) {
}

while과 do while은 c#과 기능적으로 똑같음 

반복문 끗