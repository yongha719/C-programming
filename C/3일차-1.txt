======================= 배열의 초기화 방식
배열의 초기화 방식 (다차원 배열 초기화 방식은 직접 검색해볼 것)
int arr[4]; 모든 요소가 쓰레기값
int arr[4] = {1, 2, 3, 4} /모든 요소에 데이터 넣어줌
int arr[4] = {1, 2}; / 1, 2, 0, 0 / 초기화 안해준 데이터는 0으로 초기화 시켜줌
int arr[] = {1, 2}; / int arr[2] = {1, 2}; 랑 같아서 2번째 케이스가 됨

int arr[4] = { 0 };
컴파일러가 자동으로 다 0으로 초기화해줌
왜냐 c언어 표준이라 컴파일러가 자동으로 해주는거임

베스트 프랙티스
0뒤에 , 붙여서 가독성을 높이자
첫번째 요소만 초기화해준다는게 아니라는것을 명시

4 바이트 * 512 * 512 

2048 바이트 * 512 = 2kb * 512 = 1mb 이기 때문 후훗

스택 오버플로우 
스택 메모리의 크기는 1mb이기 때문이다.

======================================= 
sizeof

size_t 

sizeof가 컴파일시에 평가될 수 있는 이유
변수가 컴파일시 스택을 얼마나 차지하는지 알고 있기 때문

size_t arr_size = sizeof(arr) / sizeof(arr[0]);

배열을 매개변수로 받는 함수 스택 프레임의 크기는 다 다를까?

컴파일러는 어셈블리 코드로 바꿔주는데 함수 코드 작성시에 
호출시 함수 인자값을 고려하는 코드를 작성할 수 없음
요소가 몇개인지 모르기 때문에 알려면 런타임이 진행되어야 하기 때문
그래서 요소가 몇개 들어오는지 알 수 없다.

함수 호출 부분에서 보면 정의된 함수로 점프하는 코드만 작성해주고
스택에서 값 복사만 해오고 몇개가 넘어오는지 모름

변수를 넘겨주는 경우가 많기 때문에 런타임에 측정되는 것들이 많기 때문에
컴파일 시에는 알 수 없음 

함수 인자값에 따른 컴파일 코드를 작성할 수 없음

메모리 성능 측면에서도 좋지 않음 
요소가 많을 경우 복사하는 시간이 걸리고 스택 오버플로우 발생 가능성이 있음

배열 요소를 매개변수를 넘길때는 배열의 시작하는 주소만 스택에 복사함
이 배열을 쓰는 함수는 주소를 이용해 간접적으로 이용할 뿐임
배열은 메모리가 붙어있기 때문에 주소연산을 이용하여 간접적으로 접근할 수 있음
이 접근 방식이 바로 포인터 연산

피호출자의 기준
자기 자신을 작성할 때는 어셈블리로 그냥 작성할 뿐임
요소의 개수를 넘겨주는게 없음


주소값을 스택에 복사하면 원본을 변경할 수 있음
참조형이 된다는 의미

포인터의 메모리 용량은 word 바이트를 따라감 
32비트 환경에서는 32비트

int f(int arr[])
{
    arr[2] = 0;
}

int main(void)
{
    int arr[5] = { 1, 2, 3, 4, 5};
    size_t i;

    f(arr); /* 나중에 배우겠지만 배열의 시작 주소이기 때문에 0번째 요소의 주소 값과 같음. f(&arr[0]); /

    for (i = 0; i < 5; ++i) { / 1 2 0 4 5 */
        printf("%d ", arr[i]);
    }
}

배열을 매개변수로 받으면 주소를 넘긴다.
매개변수를 수정하면 원본이 바뀐다.
왜냐 자세한건 포인터 배울때 나옴 ㅋ

(그 주소에 있는 값은 함수 호출할 때 넣어주었던 
자신의 배열의 주소값을 참조해서 변경하기 때문이다.)

결론

sizeof에서 뭐가 문제였느냐

매개변수로 받은 배열의 크기가 word 바이트나와서
복습안했지 너 error

배열의 크기를 못 구함
끝을 어떻게 아느냐

바로바로 매개변수로 배열의 크기를 같이 넘겨줌

void f(size_t length, int arr[length])
{
    size_t i;
    for (i = 0; i < length; ++i) { /* 1 2 3 4 5 */
        printf("%d ", arr[i]);
    }
}

int main(void)
{
    int arr[] = { 1, 2, 3, 4, 5 };
    size_t arr_length = sizeof(arr) / sizeof(arr[0]);
    f(arr_length, arr);
}

이런식으로 size_t 를 넘겨줌

size_t 를 넘겨주는 이유 모르면
복습안했지

unsigned 정수를 typedef로 재정의

c는 배열의 크기를 넘어서 접근해도 오류가 나지 않아요
인덱스 순회를 잘못하면 이상한 메모리에 접근할 수 있고
수정할 경우 이상한 메모리를 바꿀 수 있음
스택 프레임밖에 있는 메모리에 접근할 수 있음
위험

그래서 이걸 메모리 stomp가 발생할 수 있다.
이 현상이 발생하면 버그가 언제 날지 모름
바로 일어나지 않고 다른 코드를 실행하다가 뻗을 수 있음
버그 재현 시기나 버그 현상도 다 다를 수 있어서 위험
진짜 언제 일어날지 모름
이틀뒤나 한달뒤에 일어날 수 있음


c에서의 다차원 배열 표기법은 c#과 다름
int** pa


int[,] arr = new int[3,2]; // C#
int arr[3][2]; /* C */
// C# 가변 배열. 위에 배열이랑 다른 형태임
int[][] arr = new int[3][];
arr[0] = new int[5];
arr[1] = new int[2];
arr[2] = new int[3];

다차원 배열은 메모리상에서 모두 일렬로 담김
컴퓨터가 계산하는데 빨라서
개발자가 이해하기 쉽도록 만든것 뿐
2차원 배열을 1차원 배열로 만들 수 있어야 함

int arr[3][2];
int y;
int x;
for (y = 0; y < 3; ++y) { /* 모든 요소 0으로 초기화 */
    for (x = 0; x < 2; ++x) {
        arr[y][x] = 0;
    }
}

int arr[3 * 2];

size_t x;
size_t y;
for(x = 0; x < 2; x++){
    for(y= 0; y<3;y++){
        arr[(x * 3) + y] =0;
    }
}
