======================= 범위

스코프(블록) 범위
파일 범위
함수 범위
함수 선언 범위

스코프 범위
{} 둘러싼 범위

함수 조건문 반복문

예시 : 함수 블록, 조건문 블록, 반복문 블록
void a() { int num = 2; }
void b() { printf("%d", num); /* 컴파일 에러 */ }
void f()
{
    int num = 2;
    if (num == 2) {
        int num2 = 3; /* 새로운 범위이므로 선언 가능 /
        printf("%d", num);
    }

    {
        int num = 0; / 안쪽 범위에서 같은 이름의 변수를 생성하는 것은 안 좋음 [변수 가리기]
                            이름만 같고 실제로는 다른 변수임. 이렇게 선언하면 먼저 선언했던 이름 같은 변수는 못 쓰게 됨 /
        printf("%d", num); / 0 /
    }
    printf("%d", num); / 2 /
    printf("%d", num2); / 컴파일 에러 */
}

- 파일 범위

전역변수랑 비슷함

이 파일안에서는 접근이 가능하지만 다른 파일에서는 접근이 안됨

- 함수 범위

void f()
{
    /* 변수 초기화 관련 작업 /

    if (has_bug) { / 버그 발생 시 함수 종료 구문 /
        goto function_exit;
    }

function_exit: / goto 레이블 선언 /
    / 변수 해제 관련 작업 */
}

- 함수 선언 범위

함수 매개변수끼리 서로 인식 가능

* value 값을 arr 배열 모든 요소에 넣어주는 함수 */
void initialize_arr(char value, int arr_size, char arr[arr_size]);

[] 안에 들어가는 문자는 함수 헤더에서 아무 의미 없음.
(이유는 나중에 스택 메모리 볼 때 배움)
하지만 개발자가 함수 헤더만 보고도 배열의 크기를 가늠하는데 가독성이 훨씬 좋아짐
명시해준다는 느낌

==================== const 상수

심볼릭 상수 (흔히 아는 c#의 상수) 상수에다가 별명 붙인거 PI 같은
리터럴 상수 (뜻 : 말그대로) 숫자 자체


c언어는 c#이랑 const가 다름

1번째

c언어는 함수 매개변수에 const를 넣을 수 있음
매개변수 값을 바꿀일이 없을 때 사용
c#에는 in 이라는 것이 있음


2번째 
c#에서는 const 변수에 리터럴 상수만 넣을 수 있었는데
c언어에서는 const에 변수를 넣을 수 있음

***
c언어의 상수는 변경하면 위험한 값을 상수
개발자가 실수로 값을 변경하는 일을 막아줌

베스트 프랙티스
c언어에서의 변수를 다 const로 해둠


c#에서의 const

컴파일시에 값이 평가할 수 있는 이유
1. 변수를 넣을 수 있는게 아니라 리터럴 상수를 넣기 때문에
2. 이 상수를 선언과 동시에 초기화를 해주기 때문에
소스코드에 이미 대입할 값을 알고 있고 수정할 일이 없기 때문에
즉 프로그램이 실행되기 전에 이미 값을 알 수 있다는 것이고 
프로그램이 만들어지기 전에 알 수 있기 때문에 컴파일 상수라고 하는 것

모든 개체가 똑같은 값을 가지고 있기 때문에 정적 변수임
const 변수는 static 변수이다.

const랑 비슷한 놈
readonly가 있음

외부에서 접근하거나 함수 내부에서 수정할 타이밍을 특정하지 못하기 때문에
readonly 초기화는 선언할 때와 생성자에서 밖에 안됨
readonly에 변수를 넣을 수 있으므로 
프로그램이 실행되기 전에 값을 알 수 없으니 런타임 상수임
readonly 는 개체마다 값이 다를 수 있기 때문에 기본적으로 정적 변수가 아님

c에서의 const 는 c#의 readonly 변수처럼 변수도 넣을 수 있게 만듦

const는 선언과 정의를 같이 해줘야 함

c#의 const는 상수만 대입가능해서 컴파일 상수

readonly 는 선언할 때 반드시 대입할 필요가 없고 반드시 상수를 넣을 필요도 없다.
변수도 넣을 수 있기 런타임 상수이다.

====================================== goto

goto 키워드

키워드가 있는 코드로 점프

코드순서 예측하기 힘들어짐 
goto 를 써서 이상한 곳으로 점프하면 이해하기 힘듦

첫번째 중첨된 반복문 한번에 탈출

/* goto 없는 예시. 들여쓰기 가독성이 안 좋아짐. 반복되는 코드라 빼먹을 실수할 가능성 있음 / 
exit_loop = 0;
for (i = 0; i < 10; i++) {
    for (j = 0; j < 10; j++) {
        for (k = 0; k < 10; k++) {
            / 어떤 조건으로 인해 exit_loop 값 1로 설정하여 중간에 탈출하려 함 */
            if (exit_loop != 0) {
                break;
            }
        }
        if (exit_loop != 0) {
            break;
        }
    }
    if (exit_loop != 0) {
        break;
    }
}
/* goto 예시 /
for (i = 0; i < 10; i++) {
    for (j = 0; j < 10; j++) {
        for (k = 0; k < 10; k++) {
            if (exit_loop != 0) {
                goto loop_exit;
            }
        }
    }
}
loop_exit:
/ 반복문 끝나고 진행할 코드 */

두번째
이전에 작업했던 것들을 역순으로 정리해야 할 때
작업끼리 연관이 있다.

has_error = 0;

connect_network();
if (/* 네트워크 연결 실패하면 /) {
    has_error = 1;
}

if (has_error == 0) {
    join_room();
    if (/ 방 진입 실패하면 /) {
        has_error = 1;
        disconnect_network();
    }
}

if (has_error == 0) {
    start_game();
    if (/ 게임 시작 실패하면 */) {
        has_error = 1;
        exit_room();
        disconnect_network();
    }
}

if (has_error == 0) {
    stop_game();
    exit_room();
    disconnect_network();
}

개선 방법

/* early exit 으로 개선한 예시. 오류 검사 코드는 사라졌지만, 여전히 롤백 코드는 반복됨 /

connect_network();
if (/ 네트워크 연결 실패하면 /) {
    return;
}

join_room();
if (/ 방 진입 실패하면 /) {
    disconnect_network();
    return;
}

start_game();
if (/ 게임 시작 실패하면 */) {
    exit_room();
    disconnect_network();
    return;
}

stop_game();
exit_room();
disconnect_network();

2번째 개선방안

/* goto로 개선한 예시. 롤백 코드가 반복되지 않음 /

connect_network();
if (/ 네트워크 연결 실패하면 /) {
    return;
}

join_room();
if (/ 방 진입 실패하면 /) {
    goto network_disconnect;
}

start_game();
if (/ 게임 시작 실패하면 */) {
    goto room_exit;
}

stop_game();

room_exit:
    exit_room();
network_disconnect:
    disconnect_network();

c#에서도 switch case 에서 goto 문을 이용해서 case 라벨로 이동할 수 있음
그래서 fall through

예시
switch (type)
{
    case Type.A:
        goto case Type.B; // fall through
    case Type.B:
        break;
    default:
        Debug.Assert(false);
        break;
}

예시 : 간단한 캐릭터 FSM
switch (status)
{
    case Status.CREATE:
        // 캐릭터 생성 애니메이션 처리
        goto case Status.IDLE; // 생성 모션 후 IDLE 처리로 이동
    case Status.IDLE:
        // 가만히 있는 애니메이션 처리
        break;
    case Status.RUN:
        // 달리기 애니메이션 처리
        break;
    //.... 등등 여러 타입 처리
    default:
        Debug.Assert(false);
        break;
}

베스트 프랙티스 
중첩 반복문 탈출과 역순으로 작업해야 할 때
항상 goto는 위에서 아래로 갈 것
goto 를 싫어하면 굳이 쓰지 말 것
설득에 실패하면 사람들에게 맞춰갈 것 

======================== 배열

c언어는 new를 할 필요 없음

int[] arr= new int[] { 1,2,3,4,5 }; // C#
int arr[] = { 1, 2, 3, 4, 5 }; /* C */

배열을 참조형으로 할 지 값형으로 할 지 선택임

모든 자료형을 참조형으로 만들수도 있고
값형으로 만들 수도 있음

배열 끝

===================================== 스택 메모리

프로그램이 실행되면 4가지 구역의 메모리가 생성됨

1. 코드 메모리 
코드가 저장되는 영역
(코드마다 주소를 할당)
cpu가 구문을 읽기 위해 존재하는 구역

2. 데이터 메모리
전역변수나 정적 변수가 저장되는 구역
외부에서 쓸 수 있기 때문에 어떤 타이밍에 쓸지 몰라서
실행될 때 생성된다.
프로그램이 실행될 때 생성
종료될 때 삭-제
기본적으로 스택 메모리보다 큼

3. 힙 메모리
참조형이 저장되는 구역
메모리 동적할당 배울 때 다시 봄
(new 와 delete)

4. 스택 메모리 

값형이 저장되는 구역

지역변수와 매개변수가 할당되었다가 사라지는 곳으로

스택 메모리의 크기는 컴파일시 결정
컴파일러가 스택메모리의 크기를 정해주는데
지역변수와 매개변수가 스택 메모리에 할당하고 해제하는
코드를 추가로 작성해주기 때문이다.

실행중에는 스택 메모리 크기가 변하지 않음
컴파일시에 결정을 해줬으니까 컴파일러 코드가
유동적으로 변할 수 없기 때문이다.

기본값이 1MB임
프로젝트 설정에서 바꿀 수 있음
소스 코드로는 바꿀 수 없음
위에 말함

스택 오버플로우 
스팩 프레임을 만드는 과정에서 지역변수나 매개변수를 만들고
그게 쌓이다가 스택 메모리를 넘어서면 스택 메모리의 여유가 없어져서 뻗는 현상

깊은 재귀 호출
피보나치 함수

8비트가 1바이트인 환경에서
char[1024 * 1024] 크기의 배열을 만들 때

=========작동원리

지역변수, 함수 매개변수들이 스택 메모리에 생성되고 사라짐
기본적으로 스택 자료구조와 동작 방식이 같음
선입후출 먼저 들어온 게 마지막에 나감

스택 프레임을 Push하고 Pop하는 과정의 반복

그럼 스택 프레임이란 

함수 하나가 호출될 때 함수에서 사용되는
매개변수와 지역변수들이 저장되는 스택 메모리 공간을 의미

A 함수 호출하면 A 스택 프레임이 먼저 Push됨
A 함수 실행도중 B함수를 호출하면 A 스택 프레임위에 B 스택 프레임이 생김.
Push가 된다는 뜻.

B함수가 끝나면 B 스택 프레임이 Pop됨.
A함수도 끝나면 Pop됨.

======스택 프레임이 Push될 때 내부

함수 매개변수와 지역변수들은 스택 프레임안에 들어있다고 했음

함수 호출 코드는 어떤식으로 돌아가는지 알랴줌
코드 주소로 점프하는 코드로 바뀜

함수 시작부분은 어떤식인지 알랴줌
매개변수와 지역변수만큼 스택 프레임을 확보됨
함수 매개변수는 스택 프레임을 먼저 채우는데 
이전 스택 프레임에서 현재 함수를 호출한 코드의 인자 값을 복사해와서
스택 프레임에 Push를 해준다.
그 다음 지역변수도 선언된 순서대로 Push해준다.

EBP(기준점), ESP(현재 스택 포인트)
자세한 알고 싶으면 검색






